// Gestionnaire de données avec cache et optimisations
class DataManager {
  // Supprimer un commentaire par son id
  async deleteCommentAPI(commentId) {
    try {
      const response = await fetch(`https://sqcdp-api.onrender.com/commentaires/${commentId}`, {
        method: 'DELETE'
      });
      if (!response.ok) throw new Error('Erreur suppression commentaire');
      this.cache.delete('commentaires');
      this.cache.delete('monthlyData');
      return true;
    } catch (err) {
      throw err;
    }
  }
  // Charger tous les commentaires depuis l'API
  async loadCommentaires() {
    if (this.cache.has('commentaires')) {
      return this.cache.get('commentaires');
    }
    try {
      const response = await fetch('https://sqcdp-api.onrender.com/commentaires');
      const commentaires = await response.json();
      this.cache.set('commentaires', commentaires);
      return commentaires;
    } catch (err) {
      return [];
    }
  }
  // Ajouter un commentaire via l'API
  async addCommentAPI(comment) {
    try {
      const response = await fetch('https://sqcdp-api.onrender.com/commentaires', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(comment)
      });
      const result = await response.json();
      this.cache.delete('monthlyData');
      this.cache.delete('commentaires'); // force le rechargement à jour
      return result;
    } catch (err) {
      throw err;
    }
  }
  
  // Supprimer une action par son id
  async deleteActionAPI(actionId) {
    try {
      const response = await fetch(`https://sqcdp-api.onrender.com/actions/${actionId}`, {
        method: 'DELETE'
      });
      if (!response.ok) throw new Error('Erreur suppression action');
      this.cache.delete('monthlyData');
      return true;
    } catch (err) {
      throw err;
    }
  }
  // Sauvegarder une action (création ou édition)
  async saveActionAPI(action) {
    try {
      let url = 'https://sqcdp-api.onrender.com/actions';
      let method = 'POST';
      if (action.id) {
        url = `https://sqcdp-api.onrender.com/actions/${action.id}`;
        method = 'PUT';
      }
      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(action)
      });
      const result = await response.json();
      // Invalider le cache pour forcer le rechargement des actions
      this.cache.delete('monthlyData');
      return result;
    } catch (err) {
      throw err;
    }
  }
  // Retourne un tableau des jours fériés en France pour une année donnée
  getJoursFeriesFrance(year) {
    // Jours fériés fixes
    const holidays = [
      new Date(year, 0, 1),    // Jour de l'an
      new Date(year, 4, 1),    // Fête du travail
      new Date(year, 4, 8),    // Victoire 1945
      new Date(year, 6, 14),   // Fête nationale
      new Date(year, 7, 15),   // Assomption
      new Date(year, 10, 1),   // Toussaint
      new Date(year, 10, 11),  // Armistice
      new Date(year, 11, 25)   // Noël
    ];
    // Jours fériés mobiles (Pâques, Ascension, Pentecôte)
    const easter = this.calculateEaster(year);
    // Lundi de Pâques
    const easterMonday = new Date(easter.getFullYear(), easter.getMonth(), easter.getDate() + 1);
    // Ascension (39 jours après Pâques)
    const ascension = new Date(easter.getFullYear(), easter.getMonth(), easter.getDate() + 39);
    // Pentecôte (49 jours après Pâques)
    const pentecost = new Date(easter.getFullYear(), easter.getMonth(), easter.getDate() + 49);
    // Lundi de Pentecôte (50 jours après Pâques)
    const pentecostMonday = new Date(easter.getFullYear(), easter.getMonth(), easter.getDate() + 50);
    holidays.push(easterMonday, ascension, pentecost, pentecostMonday);
    return holidays;
  }
  constructor() {
    this.cache = new Map();
    this.holidaysCache = new Map();
  }

  // Chargement des couleurs des états depuis la BDD
  async loadColors() {
    if (this.cache.has('couleurs_etats')) {
      return this.cache.get('couleurs_etats');
    }
    try {
      const response = await fetch('https://sqcdp-api.onrender.com/couleurs_etats');
      const colors = await response.json();
      this.cache.set('couleurs_etats', colors);
      return colors;
    } catch (err) {
      return [];
    }
  }

  // Chargement des labels des états depuis la BDD
  async loadLabels() {
    if (this.cache.has('libelles_etats')) {
      return this.cache.get('libelles_etats');
    }
    try {
      const response = await fetch('https://sqcdp-api.onrender.com/libelles_etats');
      const labels = await response.json();
      this.cache.set('libelles_etats', labels);
      return labels;
    } catch (err) {
      return [];
    }
  }

  // Gestion des paramètres via API

  // Chargement des axes depuis la BDD
  async loadAxes() {
    if (this.cache.has('axes')) {
      return this.cache.get('axes');
    }
    try {
      const response = await fetch('https://sqcdp-api.onrender.com/axes');
      const axes = await response.json();
      this.cache.set('axes', axes);
      return axes;
    } catch (err) {
      return [];
    }
  }

  async saveParams(params) {
    try {
      const response = await fetch('https://sqcdp-api.onrender.com/params', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(params)
      });
      const result = await response.json();
      this.cache.set('params', params);
      return result;
    } catch (err) {
      throw err;
    }
  }

  // Gestion des données mensuelles via API
  async loadData() {
    const cacheKey = 'monthlyData';
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    try {
      const response = await fetch('https://sqcdp-api.onrender.com/actions');
      const actions = await response.json();
      
      // Regroupement par mois (clé: yyyy-mm)
      const data = {};
      actions.forEach(action => {
        if (!action.echeance) return;
        const date = new Date(action.echeance);
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const monthKey = `${year}-${month}`;
        if (!data[monthKey]) data[monthKey] = { actions: [] };
        data[monthKey].actions.push(action);
      });
      
      this.cache.set(cacheKey, data);
      return data;
    } catch (err) {
      return {};
    }
  }

  calculateEaster(year) {
    const a = year % 19;
    const b = Math.floor(year / 100);
    const c = year % 100;
    const d = Math.floor(b / 4);
    const e = b % 4;
    const f = Math.floor((b + 8) / 25);
    const g = Math.floor((b - f + 1) / 3);
    const h = (19 * a + b - d - g + 15) % 30;
    const i = Math.floor(c / 4);
    const k = c % 4;
    const l = (32 + 2 * e + 2 * i - h - k) % 7;
    const m = Math.floor((a + 11 * h + 22 * l) / 451);
    const month = Math.floor((h + l - 7 * m + 114) / 31);
    const day = ((h + l - 7 * m + 114) % 31) + 1;
    return new Date(year, month - 1, day);
  }

  // Nettoyage du cache
  clearCache() {
    this.cache.clear();
  }
}

var dataManager = new DataManager();
window.dataManager = dataManager;
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { DataManager, dataManager };
}
